// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © nuniesmith

// FKS Core Trading Indicator
//@version=6
indicator(title="FKS", overlay=true)

// ====================================================================================
// INPUTS SECTION
// ====================================================================================

// --- Trend Speed Parameters ---
var group_trend_speed = "Trend Speed Analysis"
asset_type = input.string('Gold', title = 'Asset Type', options = ['Gold', 'Crypto', 'Stocks', 'Forex'], group = group_trend_speed)
max_length = input.int(20, minval = 1, title = 'Maximum Length', group = group_trend_speed)
accel_multiplier = input.float(0.02, minval = 0.01, step = 0.01, title = 'Accelerator Multiplier', group = group_trend_speed)
lookback_period = input.int(200, minval = 1, step = 1, title = 'Lookback Period', group = group_trend_speed)
min_wave_ratio = input.float(1.5, minval = 0.1, step = 0.1, title = 'Minimum Wave Ratio', group = group_trend_speed)
exit_momentum_threshold = input.float(0.7, minval = 0.1, maxval = 1.0, step = 0.1, title = 'Exit Momentum Threshold', group = group_trend_speed)

// --- Visualization Settings ---
var group_trend_colors = "Trend Speed Colors"
up_hist_col = input.color(#82ffc3, title = 'Trend Speed Up', group = group_trend_colors)
up_hist_col_bright = input.color(color.lime, title = 'Trend Speed Up Strong', group = group_trend_colors)
dn_hist_col = input.color(color.red, title = 'Trend Speed Down', group = group_trend_colors)
dn_hist_col_bright = input.color(#f78c8c, title = 'Trend Speed Down Strong', group = group_trend_colors)
show_table = input.bool(false, title = "Show Wave Analysis Table", group = group_trend_colors) // Default to false now
collen = input.int(100, step = 10, minval = 5, title = 'Collection Period', group = group_trend_colors)

// --- Pattern Detection ---
var group_patterns = "Sentiment: Pattern Detection"
length = input.int(200, title = "Support/Resistance Range Length", group = group_patterns)
signal_sensitivity = input.float(0.5, minval = 0.1, maxval = 2.0, step = 0.1, title = "Signal Sensitivity", group = group_patterns)

// --- Trend & Momentum ---
var group_sentiment_trend = "Sentiment: Trend & Momentum"
// Awesome Oscillator
fastperiod = input.int(5, title = "AO Fast Period", minval = 2, group = group_sentiment_trend)
slowperiod = input.int(34, title = "AO Slow Period", minval = 5, group = group_sentiment_trend)
signalperiod = input.int(7, title = "AO Signal Period", minval = 2, group = group_sentiment_trend)
use_ao_zero = input.bool(true, title = "Use AO Zero Cross", group = group_sentiment_trend)
use_ao_signal = input.bool(true, title = "Use AO Signal Cross", group = group_sentiment_trend)
// Market Regime
use_regime_filter = input.bool(true, title = "Use Market Regime Analysis", group = group_sentiment_trend)
regime_ma_length = input.int(200, minval = 20, title = "Regime MA Length", group = group_sentiment_trend)
regime_std_length = input.int(100, minval = 20, title = "Regime Volatility Lookback", group = group_sentiment_trend)
regime_threshold = input.float(1.0, minval = 0.1, maxval = 2.0, step = 0.1, title = "Regime Change Threshold", group = group_sentiment_trend)
// Multi-Timeframe
use_multi_timeframe = input.bool(true, title = "Use Multi-Timeframe Trend Filter", group = group_sentiment_trend)
higher_tf = input.string("60", title = "Higher Timeframe", options = ["15", "30", "60", "120", "240", "D"], group = group_sentiment_trend)
// Momentum Confirmation
momentum_lookback = input.int(3, minval = 1, title = "Momentum Lookback (ROC)", group = group_sentiment_trend)

// --- Support/Resistance Settings ---
var group_sr = "Support/Resistance Settings"
sr_lookback = input.int(20, minval = 5, title = 'S/R Lookback Periods', group = group_sr)
sr_threshold = input.float(0.3, minval = 0.1, maxval = 1.0, step = 0.1, title = 'S/R Sensitivity', group = group_sr)
include_sr = input.bool(true, title = 'Use Higher TF S/R Analysis', group = group_sr)

// --- Visual Settings ---
var group_visual = "Visual Settings"
main_col = input.color(color.blue, title = "Middle Band Color", group = group_visual)
green_color = input.color(#00ffbb, title = "Bullish Color", group = group_visual)
red_color = input.color(#ff1100, title = "Bearish Color", group = group_visual)
heat_sensative = input.int(70, minval = 10, title = "Weather Heatmap Sensitivity", group = group_visual)
clean_chart_mode = input.bool(false, title = "Clean Chart Mode", group = group_visual)
show_potential_signals = input.bool(true, title = "Show Potential Signals", group = group_visual)
show_market_phase = input.bool(false, title = "Show Market Phase Label", group = group_visual)
show_regime_labels = input.bool(false, title = "Show Market Regime Label", group = group_visual)
show_entry_labels = input.bool(true, title = "Show Signal Labels", group = group_visual)
show_session_marker = input.bool(false, title = "Show Optimal Session Area", group = group_visual)
show_entry_zones = input.bool(true, title = "Show Entry Zones", group = group_visual)
show_atr_bands = input.bool(false, title = "Show SMA-Based ATR Bands", group = group_visual)

// --- Time Settings ---
var group_time_settings = "Time Settings"
start_date = input.time(timestamp('1 Jan 2020'), "Start Date", group = group_time_settings)
timer_option = input.string('From start', title = 'Timer Option', options = ['Custom', 'From start'], group = group_time_settings)

// --- Session Settings ---
var group_session = "Session Settings"
session_type = input.string("Custom", title = "Session Type", options = ["US", "London", "Asia", "Custom"], group = group_session)
use_session_filter = input.bool(false, title = "Use Session Filter", group = group_session)
custom_start_hour = input.int(9, minval = 0, maxval = 23, title = "Custom Session Start Hour", group = group_session)
custom_end_hour = input.int(16, minval = 0, maxval = 23, title = "Custom Session End Hour", group = group_session)

// --- Volatility Settings ---
var group_volatility = "Volatility Settings"
atr_len = input.int(14, minval = 1, title = "ATR Length", group = group_volatility)
volatility_history = input.int(200, minval = 20, title = "Volatility History Length", group = group_volatility)
use_kmeans_atr = input.bool(true, title = "Use K-Means Adaptive ATR", group = group_volatility)
training_data_period = input.int(250, minval = 50, title = "Training Data Period", group = group_volatility)
recalculate_clusters = input.int(20, minval = 1, title = "Recalculate Every N Bars", group = group_volatility)
highvol = input.float(0.8, minval = 0.5, maxval = 1.0, step = 0.1, title = "High Volatility Centroid", group = group_volatility)
midvol = input.float(0.5, minval = 0.3, maxval = 0.8, step = 0.1, title = "Medium Volatility Centroid", group = group_volatility)
lowvol = input.float(0.2, minval = 0.1, maxval = 0.5, step = 0.1, title = "Low Volatility Centroid", group = group_volatility)
max_iterations = input.int(10, minval = 3, maxval = 50, title = "K-Means Max Iterations", group = group_volatility)
require_atr_minimum = input.bool(true, title = "Require Minimum Volatility", group = group_volatility)
min_volatility_percentile = input.float(0.2, minval = 0.0, maxval = 0.5, step = 0.05, title = "Minimum Volatility Percentile", group = group_volatility)
avoid_high_volatility = input.bool(true, title = "Avoid Extreme Volatility", group = group_volatility)
max_volatility_percentile = input.float(0.9, minval = 0.5, maxval = 1.0, step = 0.05, title = "Maximum Volatility Percentile", group = group_volatility)

// --- Signal Settings ---
var group_signal = "Signal Settings"
signal_quality_threshold = input.float(0.6, minval = 0.1, maxval = 1.0, step = 0.05, title = "Signal Quality Threshold", group = group_signal)
signal_cooldown = input.int(5, minval = 1, title = "Bars Between Signals", group = group_signal)
require_trend_alignment = input.bool(true, title = "Require Trend Alignment", group = group_signal)
volume_filter = input.bool(false, title = "Use Volume Filter", group = group_signal)
min_volume_threshold = input.float(1.2, minval = 0.5, maxval = 3.0, step = 0.1, title = "Minimum Volume Threshold", group = group_signal)

// ====================================================================================
// SESSION MANAGEMENT
// ====================================================================================

// Define session hours based on selection
var int start_hour = 0
var int end_hour = 0

if session_type == "US"
    start_hour := 9  // 9:30 AM ET
    end_hour := 16   // 4:00 PM ET
else if session_type == "London"
    start_hour := 8  // 8:00 AM London
    end_hour := 16   // 4:30 PM London
else if session_type == "Asia"
    start_hour := 1  // 1:00 AM Tokyo
    end_hour := 7    // 7:00 AM Tokyo
else  // Custom
    start_hour := custom_start_hour
    end_hour := custom_end_hour

// Check if current bar is in session
in_session = (hour >= start_hour and hour <= end_hour) or not use_session_filter
bgcolor(show_session_marker and in_session ? color.new(color.blue, 90) : na)

// Track session transitions
bool session_started = in_session and not in_session[1] and barstate.isconfirmed
bool session_ended = not in_session and in_session[1] and barstate.isconfirmed

// Set optimal session
bool in_optimal_session = in_session

// ====================================================================================
// ＵＴＩＬＩＴＹ ＦＵＮＣＴＩＯＮＳ
// ====================================================================================

// ————— Normalization Function
normalization(src, mean) =>
    stdev = ta.stdev(src, 200)
    norm = stdev == 0 ? 0 : (src - mean) / stdev // Avoid division by zero
    math.max(math.min(norm, 5), -5) // Clamp between -5 and 5

// ————— Rescale Function (when range is known)
rescale(src, oldMin, oldMax, newMin, newMax) =>
    oldRange = oldMax - oldMin
    newRange = newMax - newMin
    scaled = oldRange == 0 ? newMin : newMin + newRange * (src - oldMin) / oldRange // Avoid division by zero
    scaled

// ————— Regression Line Formula
f_regression_line(_len) =>
    x = bar_index
    y = hl2
    x_ = ta.sma(x, _len)
    y_ = ta.sma(y, _len)
    mx = ta.stdev(x, _len)
    my = ta.stdev(y, _len)
    // Handle potential division by zero in correlation or stdev
    slope = mx == 0 ? 0 : ta.correlation(x, y, _len) * (my / mx)
    inter = y_ - slope * x_
    x * slope + inter

// Summer Winter Logic / Heatmap
regression_line_val = f_regression_line(length)

// ————— Heat Map Color Bars (Weather indicator)
color_level = normalization(close - regression_line_val, 0)
g_p = rescale(color_level, -4, 5, 0, 30)
color heatmap_color = color_level > 0
 ? color.from_gradient(color_level, 0, math.max(ta.highest(color_level, heat_sensative), 0.0001), color.yellow, color.red) // Ensure max > min
 : color.from_gradient(color_level, math.min(ta.lowest(color_level, heat_sensative), -0.0001), 0, color.aqua, color.yellow) // Ensure max > min
barcolor(heatmap_color)

// ————— Helper function for calculating normalized ROC
f_calc_norm_roc(_offset, _len=8, _stdev_len=200) =>
    float roc_val = ta.roc(close[_offset], _len)
    // Pre-calculate stdev outside any conditionals for consistency
    float stdev_val = ta.stdev(ta.roc(close, _len), _stdev_len)
    norm_roc = stdev_val == 0 ? 0 : roc_val / stdev_val // Avoid division by zero
    norm_roc

// ====================================================================================
// SUPPORT & RESISTANCE DETECTION FUNCTIONS
// ====================================================================================

// ————— Function to find significant swing highs
find_swing_highs(src, length, threshold) =>
    var pivots = array.new_float(0)
    if pivots.size() > 10  // Limit array size for performance
        pivots.shift()

    // Pre-calculate indicator values outside of conditional blocks for consistency
    float highest_val = ta.highest(src, length - 1)
    float lowest_val = ta.lowest(src, length * 2)
    float atr_val = ta.atr(14)

    isSwingHigh = src[length] > src[length + 1] and src[length] > src[length - 1] and
                 src[length] > highest_val and
                 (src[length] - lowest_val) / atr_val > threshold

    if isSwingHigh
        pivots.unshift(src[length])

    pivots

// ————— Function to find significant swing lows
find_swing_lows(src, length, threshold) =>
    var pivots = array.new_float(0)
    if pivots.size() > 10  // Limit array size for performance
        pivots.shift()

    // Pre-calculate indicator values outside of conditional blocks for consistency
    float lowest_val = ta.lowest(src, length - 1)
    float highest_val = ta.highest(src, length * 2)
    float atr_val = ta.atr(14)

    isSwingLow = src[length] < src[length + 1] and src[length] < src[length - 1] and
                 src[length] < lowest_val and
                 (highest_val - src[length]) / atr_val > threshold

    if isSwingLow
        pivots.unshift(src[length])

    pivots

// ————— Function to get nearest level from an array
get_nearest_level(price, levels) =>
    float nearest = na
    float min_distance = float(10000000)  // Start with a large number

    // Only proceed if the array has elements
    if array.size(levels) > 0
        for i = 0 to math.min(levels.size() - 1, 5)
            level = array.get(levels, i)
            distance = math.abs(price - level)
            if distance < min_distance
                min_distance := distance
                nearest := level

    nearest

// ————— Function to determine different signal conditions based on price action
f_signals(_lowest_src, _highest_src, _adaptive_atr) =>
    // Calculate ROC using normalized ROC with offset 2
    float roc_norm_2 = f_calc_norm_roc(2) // Use helper function
    float roc_norm_0 = f_calc_norm_roc(0) // ROC on current bar

    // Pre-calculate barssince values to avoid inconsistent calculations
    int bars_since_lowest = ta.barssince(low[1] == _lowest_src[1])
    int bars_since_highest = ta.barssince(high[1] == _highest_src[1])

    // Pre-calculate ATR zone values
    float support_zone = _lowest_src + (_adaptive_atr * 0.5)
    float resistance_zone = _highest_src - (_adaptive_atr * 0.5)

    // Main signals - Resistance test
    bool top = high < _highest_src and high[1] >= _highest_src[1] and roc_norm_2 > 2 * signal_sensitivity and bars_since_lowest > 5 and barstate.isconfirmed
    bool bottom = low > _lowest_src and low[1] <= _lowest_src[1] and roc_norm_2 < -2 * signal_sensitivity and bars_since_highest > 5 and barstate.isconfirmed

    // Secondary signals
    bool simple_bottom = low > _lowest_src and low[1] <= _lowest_src[1] and not bottom and barstate.isconfirmed
    bool simple_top = high < _highest_src and high[1] >= _highest_src[1] and not top and barstate.isconfirmed

    // Potential signals (early warning) - using adaptive ATR for zone
    bool potential_bottom = low <= support_zone and roc_norm_0 < -1 * signal_sensitivity and barstate.isconfirmed
    bool potential_top = high >= resistance_zone and roc_norm_0 > 1 * signal_sensitivity and barstate.isconfirmed

    [top, bottom, simple_bottom, simple_top, potential_bottom, potential_top]

// ————— Function for lowest & highest calculation
f_lowest_highest(_len) =>
    float lowest_val = ta.lowest(low, _len) // Support level
    float highest_val = ta.highest(high, _len) // Resistance level
    float mid_val = ta.hma(math.avg(lowest_val, highest_val), 15) // Middle reference line
    [lowest_val, highest_val, mid_val]

// ————— Detect basic candlestick patterns
f_detect_bullish_candle_pattern() =>
    body_size = math.abs(close - open)
    candle_range = high - low
    candle_range := candle_range == 0 ? 0.00001 : candle_range // Avoid division by zero
    lower_wick = math.min(open, close) - low
    upper_wick = high - math.max(open, close)

    // Hammer pattern (small body, long lower wick)
    hammer = body_size < candle_range * 0.3 and lower_wick > body_size * 2 and upper_wick < body_size

    // Bullish engulfing (current green body engulfs previous red body)
    bullish_engulfing = close > open and close[1] < open[1] and close > open[1] and open < close[1]

    // Pin bar / rejection (long lower wick rejecting lower prices)
    pin_bar = lower_wick > candle_range * 0.6 and body_size < candle_range * 0.3 and upper_wick < candle_range * 0.3

    hammer or bullish_engulfing or pin_bar

f_detect_bearish_candle_pattern() =>
    body_size = math.abs(close - open)
    candle_range = high - low
    candle_range := candle_range == 0 ? 0.00001 : candle_range // Avoid division by zero
    lower_wick = math.min(open, close) - low
    upper_wick = high - math.max(open, close)

    // Shooting star (small body, long upper wick)
    shooting_star = body_size < candle_range * 0.3 and upper_wick > body_size * 2 and lower_wick < body_size

    // Bearish engulfing (current red body engulfs previous green body)
    bearish_engulfing = close < open and close[1] > open[1] and close < open[1] and open > close[1]

    // Pin bar / rejection (long upper wick rejecting higher prices)
    pin_bar = upper_wick > candle_range * 0.6 and body_size < candle_range * 0.3 and lower_wick < candle_range * 0.3

    shooting_star or bearish_engulfing or pin_bar

// ====================================================================================
// TREND SPEED ANALYZER FUNCTIONALITY
// ====================================================================================

// Override parameters based on asset type
// This is done after declaration to handle the runtime adjustment
if barstate.isfirst
    max_length := switch asset_type
        'Crypto' => 20
        'Gold' => 20
        'Stocks' => 20
        'Forex' => 20

    accel_multiplier := switch asset_type
        'Crypto' => 0.03
        'Gold' => 0.015
        'Stocks' => 0.01
        'Forex' => 0.02

    lookback_period := switch asset_type
        'Crypto' => 100
        'Gold' => 200
        'Stocks' => 150
        'Forex' => 150

// Define StartTime function
StartTime() =>
    timer_option == "Custom" ? time > start_date : true

// ~~  Dynamic Average Calculation
counts_diff = close
max_abs_counts_diff = ta.highest(math.abs(counts_diff), 200)
counts_diff_norm = (counts_diff + max_abs_counts_diff) / (2 * max_abs_counts_diff)
dyn_length = 5 + counts_diff_norm * (max_length - 5)

// Function to compute the accelerator factor with normalization of delta_counts_diff
calc_accel_factor(float counts_diff, float prev_counts_diff) =>
    // Compute the change in counts_diff
    delta_counts_diff = math.abs(counts_diff - prev_counts_diff)

    // Normalize delta_counts_diff over last 200 bars
    float max_delta_counts_diff = ta.highest(delta_counts_diff, 200)
    max_delta_counts_diff := max_delta_counts_diff == 0 ? 1 : max_delta_counts_diff

    // Compute accelerator factor
    float accel_factor = delta_counts_diff / max_delta_counts_diff

    // Return accelerator factor
    accel_factor

// Function to adjust alpha using the accelerator factor - MODIFIED FOR IMPROVED SENSITIVITY
adjust_alpha(float dyn_length, float accel_factor, float accel_multiplier) =>
    // Adjust alpha with accelerator factor
    alpha_base = 2 / (dyn_length + 1)
    alpha = alpha_base * (1 + accel_factor * accel_multiplier * 0.8) // Reduced sensitivity by 20%
    alpha := math.min(0.9, alpha)  // Cap at 0.9 instead of 1.0 for smoother transitions

    // Return the adjusted alpha
    alpha

// Accelerator Factor
accel_factor = calc_accel_factor(counts_diff, nz(counts_diff[1]))
alpha = adjust_alpha(dyn_length, accel_factor, accel_multiplier)

// Compute dynamic Ema
var float dyn_ema = na
dyn_ema := na(dyn_ema[1]) ? close : alpha * close + (1 - alpha) * dyn_ema[1]

// ~~ Trend Speed Logic
trend = dyn_ema
bullsrc = close
bearsrc = close

type TrendData
    array<float> change
    array<int> t

var bullish = TrendData.new(array.new<float>(), array.new<int>())
var bearish = TrendData.new(array.new<float>(), array.new<int>())
var x1 = int(na)
var y1 = float(na)
var pos = 0
var speed = 0.0
c = ta.rma(close, 10)
o = ta.rma(open, 10)

// First value initialization
if na(x1) and StartTime()
    x1 := bar_index
    y1 := o

// Trend direction calculation
// Calculate these values on every bar for consistency
float lowest_speed = ta.lowest(speed, math.max(1, bar_index - x1))
float highest_speed = ta.highest(speed, math.max(1, bar_index - x1))

if StartTime()
    if bullsrc > trend and bullsrc[1] <= trend
        bearish.change.unshift(lowest_speed)
        bearish.t.unshift(bar_index - x1)
        x1 := bar_index
        y1 := bullsrc
        pos := 1
        speed := c - o

    if bearsrc < trend and bearsrc[1] >= trend
        bullish.change.unshift(highest_speed)
        bullish.t.unshift(bar_index - x1)
        x1 := bar_index
        y1 := bearsrc
        pos := -1
        speed := c - o

speed := speed + c - o
trendspeed = ta.hma(speed, 5)

// Trend-based wave analysis
is_trending_up = ta.wma(close, 2) > dyn_ema
is_trending_down = ta.wma(close, 2) < dyn_ema

// Identify pullbacks to MA
pullback_to_ma = close[1] < dyn_ema and close > dyn_ema and low <= dyn_ema // Bullish rejection
pullback_to_ma_bear = close[1] > dyn_ema and close < dyn_ema and high >= dyn_ema // Bearish rejection

// Signal variables for tracking momentum
var float highest_recent_momentum = 0.0
var int exit_cooldown = 0  // Cooldown counter to avoid too many exit signals
var bool prev_in_trade = false  // Track if we were previously in a trade

// Only update highest momentum when we have significant movement
if math.abs(speed) > highest_recent_momentum * 0.9
    highest_recent_momentum := math.max(highest_recent_momentum, math.abs(speed))

// Calculate momentum ratio - how current momentum compares to recent peak
momentum_ratio = math.abs(speed) / (highest_recent_momentum == 0 ? 1 : highest_recent_momentum)

// Calculate dynamic wave ratio based on currently available data
float current_ratio = 0.0
if array.size(bullish.change) > 0 and array.size(bearish.change) > 0
    // Get most recent values for comparison
    bullish_sample = array.get(bullish.change, 0)
    bearish_sample = array.get(bearish.change, 0)

    // Calculate ratio based on whether current wave is positive or negative
    current_ratio := speed > 0 ?
         speed / (bullish_sample == 0 ? 0.0001 : bullish_sample) :
         speed / (bearish_sample == 0 ? -0.0001 : math.abs(bearish_sample))

// SpeedGradient calculation for visualization
min_speed = ta.lowest(speed, collen)
max_speed = ta.highest(speed, collen)
normalized_speed = (speed - min_speed) / (max_speed - min_speed > 0 ? max_speed - min_speed : 1) // Avoid division by zero
speedGradient1 = speed < 0 ?
     color.from_gradient(normalized_speed, 0.0, 0.5, dn_hist_col, dn_hist_col_bright) :
     color.from_gradient(normalized_speed, 0.5, 1.0, up_hist_col, up_hist_col_bright)

// ====================================================================================
// WAVE ANALYSIS CALCULATIONS - GLOBAL VARIABLES
// ====================================================================================

// Calculate recent bullish and bearish changes for trend speed analysis
// Make these calculations available globally
var float bull_max = 0.0001
var float bear_max = -0.0001
var float bull_avg = 0.0001
var float bear_avg = -0.0001
var string wave_size_text_avg = "0.0x"
var string wave_size_text_max = "0.0x"
var color wave_size_color_avg = color.lime
var color wave_size_color_max = color.lime
var string dominance_avg_text = "Neutral"
var string dominance_max_text = "Neutral"
var color dominance_avg_color = color.silver
var color dominance_max_color = color.silver
var float wave_size_ratio_avg = 1.0
var float wave_size_ratio_max = 1.0
var float current_ratio_avg = 0.0
var float current_ratio_max = 0.0
var string current_text_avg = "0.0x"
var string current_text_max = "0.0x"
var color current_color_avg = color.lime
var color current_color_max = color.lime
var float dominance_avg_value = 0.0
var float dominance_max_value = 0.0

// Update the wave analysis calculations every bar
if barstate.isconfirmed
    // We'll calculate these values globally so they're available to both panels
    bullish_recent = array.size(bullish.change) > 0 ?
         array.slice(bullish.change, 0, math.min(lookback_period, array.size(bullish.change))) :
         array.new<float>()

    bearish_recent = array.size(bearish.change) > 0 ?
         array.slice(bearish.change, 0, math.min(lookback_period, array.size(bearish.change))) :
         array.new<float>()

    // Calculate trend speed stats
    bull_max := array.size(bullish_recent) > 0 ? array.max(bullish_recent) : 0.0001
    bear_max := array.size(bearish_recent) > 0 ? array.min(bearish_recent) : -0.0001
    bull_avg := array.size(bullish_recent) > 0 ? array.avg(bullish_recent) : 0.0001
    bear_avg := array.size(bearish_recent) > 0 ? array.avg(bearish_recent) : -0.0001

    // Calculate wave size ratios for max and average wave heights
    wave_size_ratio_avg := bull_avg / math.abs(bear_avg)
    wave_size_text_avg := str.tostring(math.round(wave_size_ratio_avg, 2)) + 'x'
    wave_size_color_avg := wave_size_ratio_avg > 0 ? color.lime : color.red

    wave_size_ratio_max := bull_max / math.abs(bear_max)
    wave_size_text_max := str.tostring(math.round(wave_size_ratio_max, 2)) + 'x'
    wave_size_color_max := wave_size_ratio_max > 0 ? color.lime : color.red

    // Dominance calculation
    dominance_avg_value := bull_avg - math.abs(bear_avg)
    dominance_avg_text := dominance_avg_value > 0 ?
         'Bullish +' + str.tostring(math.round(wave_size_ratio_avg, 2)) + 'x' :
         'Bearish -' + str.tostring(math.round(math.abs(bear_avg) > 0 ? 1 / wave_size_ratio_avg : 0, 2)) + 'x'
    dominance_avg_color := dominance_avg_value > 0 ? color.lime : color.red

    dominance_max_value := bull_max - math.abs(bear_max)
    dominance_max_text := dominance_max_value > 0 ?
         'Bullish +' + str.tostring(math.round(wave_size_ratio_max, 2)) + 'x' :
         'Bearish -' + str.tostring(math.round(math.abs(bear_max) > 0 ? 1 / wave_size_ratio_max : 0, 2)) + 'x'
    dominance_max_color := dominance_max_value > 0 ? color.lime : color.red

    // Current wave calculations
    current_wave = speed
    current_wave_color = current_wave > 0 ? color.lime : color.red

    current_ratio_avg := current_wave > 0 ? current_wave / bull_avg : current_wave / math.abs(bear_avg)
    current_ratio_max := current_wave > 0 ? current_wave / bull_max : current_wave / math.abs(bear_max)

    current_text_avg := str.tostring(math.round(current_ratio_avg, 2)) + 'x'
    current_text_max := str.tostring(math.round(current_ratio_max, 2)) + 'x'

    current_color_avg := current_ratio_avg > 0 ? color.lime : color.red
    current_color_max := current_ratio_max > 0 ? color.lime : color.red

// Function to directly get nearest levels without intermediate arrays
get_nearest_sr_levels(timeframe) =>
    // Get S/R levels for this timeframe
    request_result_highs = request.security(syminfo.tickerid, timeframe, find_swing_highs(high, sr_lookback, sr_threshold), lookahead=barmerge.lookahead_off)
    request_result_lows = request.security(syminfo.tickerid, timeframe, find_swing_lows(low, sr_lookback, sr_threshold), lookahead=barmerge.lookahead_off)

    // Find nearest level directly
    nearest_res = get_nearest_level(close, request_result_highs)
    nearest_sup = get_nearest_level(close, request_result_lows)

    [nearest_res, nearest_sup]

// Initialize nearest level variables once
var float nearest_resistance_1m = na
var float nearest_support_1m = na
var float nearest_resistance_5m = na
var float nearest_support_5m = na

// Only calculate S/R levels if needed
if include_sr
    // Get 1-minute levels - use := for reassignment to avoid shadowing
    [resistance_1m_temp, support_1m_temp] = get_nearest_sr_levels("1")
    nearest_resistance_1m := resistance_1m_temp
    nearest_support_1m := support_1m_temp

    // Get 5-minute levels - use := for reassignment to avoid shadowing
    [resistance_5m_temp, support_5m_temp] = get_nearest_sr_levels("5")
    nearest_resistance_5m := resistance_5m_temp
    nearest_support_5m := support_5m_temp
else
    // Reset to na if not using S/R
    nearest_resistance_1m := na
    nearest_support_1m := na
    nearest_resistance_5m := na
    nearest_support_5m := na

// Determine long/short bias based on position relative to S/R levels
bool long_bias_1m = include_sr and not na(nearest_support_1m) and not na(nearest_resistance_1m) ?
     close > nearest_support_1m and nearest_resistance_1m - close > close - nearest_support_1m :
     false
bool short_bias_1m = include_sr and not na(nearest_support_1m) and not na(nearest_resistance_1m) ?
     close < nearest_resistance_1m and nearest_resistance_1m - close < close - nearest_support_1m :
     false
bool long_bias_5m = include_sr and not na(nearest_support_5m) and not na(nearest_resistance_5m) ?
     close > nearest_support_5m and nearest_resistance_5m - close > close - nearest_support_5m :
     false
bool short_bias_5m = include_sr and not na(nearest_support_5m) and not na(nearest_resistance_5m) ?
     close < nearest_resistance_5m and nearest_resistance_5m - close < close - nearest_support_5m :
     false

// ====================================================================================
// ＶＯＬＡＴＩＬＩＴＹ ＡＮＡＬＹＳＩＳ (ATR & K-Means)
// ====================================================================================

// Calculate raw ATR with safeguards against NaN
float volatility = nz(ta.atr(atr_len), 0.00001)
volatility := volatility <= 0 ? 0.00001 : volatility  // Ensure non-zero positive value

// Calculate standard ATR(14) for general context/backup
var float atr_14 = ta.atr(14)
atr_14 := nz(ta.atr(14), volatility) // Use raw volatility as fallback

// --- K-Means Clustering for Adaptive ATR (Optional) ---
var float adaptive_atr = volatility // Default to raw volatility
var string vol_status = "MEDIUM" // Default status
var int cluster = 1 // Default cluster (medium)

float k_upper = ta.highest(volatility, training_data_period)
float k_lower = ta.lowest(volatility, training_data_period)

// Add missing volatility regime multiplier for SL calculations
var float vol_multiplier = 1.0

// Performance optimization - only run on specific bars
bool should_run_kmeans = (bar_index % recalculate_clusters == 0 or bar_index == training_data_period) and barstate.isconfirmed

if use_kmeans_atr and should_run_kmeans
    // Find range for initial centroids
    float upper = nz(k_upper, volatility * 1.5)
    float lower = nz(k_lower, volatility * 0.5)
    float atr_range = upper - lower
    atr_range := atr_range <= 0 ? volatility : atr_range // Ensure a minimum range

    // Calculate initial centroids
    float high_volatility_init = lower + atr_range * highvol
    float medium_volatility_init = lower + atr_range * midvol
    float low_volatility_init = lower + atr_range * lowvol

    // Variables for K-means clustering
    var int iterations = 0
    var array<float> hv = array.new_float(0) // Initialize empty, let them grow
    var array<float> mv = array.new_float(0)
    var array<float> lv = array.new_float(0)
    // Store only the current and previous mean for convergence check
    var float current_amean = high_volatility_init
    var float previous_amean = high_volatility_init
    var float current_bmean = medium_volatility_init
    var float previous_bmean = medium_volatility_init
    var float current_cmean = low_volatility_init
    var float previous_cmean = low_volatility_init

    // Ensure initial values are valid
    current_amean := nz(current_amean, high_volatility_init)
    previous_amean := nz(previous_amean, high_volatility_init)
    current_bmean := nz(current_bmean, medium_volatility_init)
    previous_bmean := nz(previous_bmean, medium_volatility_init)
    current_cmean := nz(current_cmean, low_volatility_init)
    previous_cmean := nz(previous_cmean, low_volatility_init)

    if nz(volatility) > 0 and bar_index >= training_data_period - 1
        iterations := 0
        bool continue_iteration = true

        while (continue_iteration and iterations < max_iterations)
            hv.clear()
            mv.clear()
            lv.clear()

            for i = 0 to training_data_period - 1
                float val = nz(volatility[i], volatility) // Use current volatility as fallback for NaN in history
                // Use the 'current' mean from the previous iteration for assignment
                float _1 = math.abs(val - current_amean)
                float _2 = math.abs(val - current_bmean)
                float _3 = math.abs(val - current_cmean)

                if _1 <= _2 and _1 <= _3
                    hv.push(val)
                else if _2 <= _1 and _2 <= _3
                    mv.push(val)
                else // if _3 <= 1 and _3 <= 2
                    lv.push(val)

            // Safe average calculation with fallback to the current mean
            float new_amean_calc = hv.size() > 0 ? hv.avg() : current_amean
            float new_bmean_calc = mv.size() > 0 ? mv.avg() : current_bmean
            float new_cmean_calc = lv.size() > 0 ? lv.avg() : current_cmean

            // Ensure no NaN values and provide default fallbacks using initial estimates
            new_amean_calc := nz(new_amean_calc, high_volatility_init)
            new_bmean_calc := nz(new_bmean_calc, medium_volatility_init)
            new_cmean_calc := nz(new_cmean_calc, low_volatility_init)

            // Check for convergence comparing the newly calculated mean with the 'current' mean
            float convergence_threshold = volatility * 0.001 // Relative threshold
            bool a_converged = math.abs(new_amean_calc - current_amean) < convergence_threshold
            bool b_converged = math.abs(new_bmean_calc - current_bmean) < convergence_threshold
            bool c_converged = math.abs(new_cmean_calc - current_cmean) < convergence_threshold

            // Update means: shift 'current' to 'previous', assign 'new' to 'current'
            previous_amean := current_amean
            previous_bmean := current_bmean
            previous_cmean := current_cmean
            current_amean := new_amean_calc
            current_bmean := new_bmean_calc
            current_cmean := new_cmean_calc

            continue_iteration := not (a_converged and b_converged and c_converged)
            iterations := iterations + 1

    // Get final centroids from the 'current' mean variables
    float hv_new = nz(current_amean, high_volatility_init)
    float mv_new = nz(current_bmean, medium_volatility_init)
    float lv_new = nz(current_cmean, low_volatility_init)

    // Determine which cluster the current volatility belongs to
    float vdist_a = math.abs(volatility - hv_new)
    float vdist_b = math.abs(volatility - mv_new)
    float vdist_c = math.abs(volatility - lv_new)

    // Find the index of the minimum distance
    cluster := vdist_a <= vdist_b and vdist_a <= vdist_c ? 0 :
               vdist_b <= vdist_a and vdist_b <= vdist_c ? 1 : 2

    // Final adaptive ATR based on cluster centroid
    adaptive_atr := cluster == 0 ? hv_new : cluster == 1 ? mv_new : lv_new
    adaptive_atr := nz(adaptive_atr, volatility) // Final fallback

    vol_status := cluster == 0 ? "HIGH" : (cluster == 1 ? "MEDIUM" : "LOW")

    // Set volatility multiplier for SL calculations
    vol_multiplier := cluster == 0 ? 0.8 : cluster == 1 ? 1.0 : 1.2 // Adjust SL multiplier based on volatility

// --- Volatility Percentile & Regime ---

// Store historical volatility for percentile calculation
var volatility_array = array.new_float(volatility_history, volatility) // Initialize with current volatility

// Update volatility array (optimized)
if barstate.isconfirmed // Update only on confirmed bars
    volatility_array.push(volatility)
    if volatility_array.size() > volatility_history
        volatility_array.shift()

// Determine volatility percentile
float volatility_percentile = 0.5 // Default
if volatility_array.size() > 1
    int count_less = 0
    for i = 0 to volatility_array.size() - 1
        if volatility_array.get(i) < volatility
            count_less += 1
    volatility_percentile := count_less / volatility_array.size()

// Create volatility regime labels based on percentile
string volatility_regime = "MEDIUM" // Default
if volatility_percentile < 0.2
    volatility_regime := "VERY LOW"
else if volatility_percentile < 0.4
    volatility_regime := "LOW"
// else if volatility_percentile < 0.6 // Medium is default
else if volatility_percentile >= 0.8
    volatility_regime := "VERY HIGH"
else if volatility_percentile >= 0.6
    volatility_regime := "HIGH"

// Check volatility filter conditions using percentile
bool volatility_within_range = true
if require_atr_minimum and volatility_percentile < min_volatility_percentile
    volatility_within_range := false
if avoid_high_volatility and volatility_percentile > max_volatility_percentile
    volatility_within_range := false

// ====================================================================================
// ＭＡＲＫＥＴ ＲＥＧＩＭＥ ＤＥＴＥＣＴＩＯＮ
// ====================================================================================

// Get higher timeframe trend MA (Fixed lookahead bias)
float higher_tf_ma = request.security(syminfo.tickerid, higher_tf, ta.sma(close, 50), lookahead=barmerge.lookahead_off)

// Slope calculation for trend strength
float ma_current = ta.sma(close, regime_ma_length)
float ma_prev = nz(ma_current[20], ma_current) // Use current if previous is na
float ma_slope = (ma_current - ma_prev) / 20

// Normalized slope for regime strength
float avg_slope_abs = ta.sma(math.abs(ta.change(ma_current)), regime_std_length)
float norm_slope = avg_slope_abs == 0 ? 0 : ma_slope / avg_slope_abs // Avoid division by zero

// Volatility calculation (using standard deviation of returns)
float returns = ta.change(close) / nz(close[1], close)
float current_volatility_std = ta.stdev(returns, regime_std_length)
float avg_volatility_std = ta.sma(current_volatility_std, 50)
float norm_volatility = avg_volatility_std == 0 ? 1 : current_volatility_std / avg_volatility_std // Avoid division by zero, default to 1

// Define market regimes
string market_regime = "NEUTRAL" // Default
if norm_slope > regime_threshold // Trending Bull
    market_regime := "TRENDING BULL"
else if norm_slope < -regime_threshold // Trending Bear
    market_regime := "TRENDING BEAR"
else // Not strongly trending
    if norm_volatility > 1.5 // High Volatility Chop?
        market_regime := "VOLATILE"
    else if norm_volatility < 0.8 // Low Volatility Range?
        market_regime := "RANGING"
    // else remains NEUTRAL

// Track regime changes for alerts
var string prev_market_regime = market_regime
bool regime_changed = market_regime != prev_market_regime and bar_index > 5
prev_market_regime := market_regime

// Add regime SL modifier based on market regime (needed for SL calculation)
float regime_sl_modifier = 1.0
if market_regime == "TRENDING BULL" or market_regime == "TRENDING BEAR"
    regime_sl_modifier := 1.2 // More room in trending markets
else if market_regime == "VOLATILE"
    regime_sl_modifier := 1.5 // Even more room in volatile markets
else if market_regime == "RANGING"
    regime_sl_modifier := 0.8 // Tighter stops in ranging markets
// else remains 1.0 for NEUTRAL

// ====================================================================================
// ＭＯＭＥＮＴＵＭ ＆ ＰＡＴＴＥＲＮ ＣＡＬＣＵＬＡＴＩＯＮＳ
// ====================================================================================

// --- Momentum Features ---
float price_velocity_raw = ta.change(close, momentum_lookback) / nz(close[momentum_lookback], close)
float price_acceleration_raw = ta.change(price_velocity_raw, momentum_lookback) // Added missing price_acceleration variable
float stdev_velocity = ta.stdev(price_velocity_raw, 100)
float normalized_velocity = stdev_velocity == 0 ? 0 : price_velocity_raw / stdev_velocity // Normalized Velocity
float price_acceleration = stdev_velocity == 0 ? 0 : price_acceleration_raw / stdev_velocity // Fixed normalized acceleration

// Calculate Support & Resistance values
[lowest_src, highest_src, mid] = f_lowest_highest(length)
[top, bottom, simple_bottom, simple_top, potential_bottom, potential_top] = f_signals(lowest_src, highest_src, adaptive_atr) // Pass adaptive_atr

// Pre-calculate barssince values for recent signals to ensure consistency
var int bars_since_top = 0
var int bars_since_g = 0

// Update the barssince values on each bar
if (barstate.isconfirmed)
    bars_since_top := top ? 0 : nz(bars_since_top[1]) + 1
    bars_since_g := bottom ? 0 : nz(bars_since_g[1]) + 1

// --- Awesome Oscillator Calculations ---
fastMA = ta.sma(hl2, fastperiod)
slowMA = ta.sma(hl2, slowperiod)
AO = fastMA - slowMA
signal = ta.sma(AO, signalperiod)

// AO crossover detection
bool ao_zero_cross_up = ta.crossover(AO, 0)
bool ao_zero_cross_down = ta.crossunder(AO, 0)
bool ao_signal_cross_up = ta.crossover(AO, signal)
bool ao_signal_cross_down = ta.crossunder(AO, signal)

// Combined AO state conditions
bool ao_bullish = (use_ao_zero and AO > 0) or (use_ao_signal and AO > signal)
bool ao_bearish = (use_ao_zero and AO < 0) or (use_ao_signal and AO < signal)

// More specific crossover confirmations based on user input settings
bool ao_cross_bull = (use_ao_zero and ao_zero_cross_up) or (use_ao_signal and ao_signal_cross_up)
bool ao_cross_bear = (use_ao_zero and ao_zero_cross_down) or (use_ao_signal and ao_signal_cross_down)

// --- Price Location Context (Relative to Top G Bands using ATR) ---
float support_zone_upper = lowest_src + adaptive_atr * 0.5 // Define support zone using adaptive ATR
float resistance_zone_lower = highest_src - adaptive_atr * 0.5 // Define resistance zone using adaptive ATR

bool price_near_support = low <= support_zone_upper // Price entered or is near the support zone
bool price_near_resistance = high >= resistance_zone_lower // Price entered or is near the resistance zone

// --- Initial Signal Confirmation (Pattern + AO State) ---
// These are preliminary checks before full quality/filter assessment
bool long_signal_prelim = (bottom or simple_bottom) and ao_bullish
bool short_signal_prelim = (top or simple_top) and ao_bearish

// ====================================================================================
// ＳＩＧＮＡＬ ＬＯＧＩＣ & ＭＡＲＫＥＴ ＰＨＡＳＥＳ
// ====================================================================================

// Market phase detection
var market_phase = "ACCUMULATION"
var color phase_color = color.yellow

// Track higher highs and lower lows for trend determination
var float prev_swing_high = highest_src[10]
var float prev_swing_low = lowest_src[10]

// Detect market phases
if ta.crossover(close, highest_src[10]) and AO > 0
    market_phase := "UPTREND"
    phase_color := color.green
    prev_swing_high := close

if ta.crossunder(close, lowest_src[10]) and AO < 0
    market_phase := "DOWNTREND"
    phase_color := color.red
    prev_swing_low := close

if close > highest_src[5] and close < highest_src and AO > 0 and AO < AO[10]
    market_phase := "DISTRIBUTION"
    phase_color := color.orange

if close < lowest_src[5] and close > lowest_src and AO < 0 and AO > AO[10]
    market_phase := "ACCUMULATION"
    phase_color := color.yellow

// Signal confirmation with AO
bool long_signal = bottom and ao_bullish
bool short_signal = top and ao_bearish

// Calculate price range for entry zones
float price_range = highest_src - lowest_src

// ====================================================================================
// ＳＥＮＴＩＭＥＮＴ ＆ ＳＩＧＮＡＬ ＱＵＡＬＩＴＹ ＬＯＧＩＣ
// ====================================================================================

// Calculate RSI first to ensure it's executed on every bar
float rsi_value = ta.rsi(close, 14)

// Trend alignment check using the pre-calculated RSI value
bool in_uptrend = market_phase == "UPTREND" or (market_phase == "ACCUMULATION" and AO > 0 and rsi_value > 50)
bool in_downtrend = market_phase == "DOWNTREND" or (market_phase == "DISTRIBUTION" and AO < 0 and rsi_value < 50)

// Multi-timeframe trend alignment
bool strong_trend_aligned = use_multi_timeframe ? (in_uptrend and close > higher_tf_ma) or
                                             (in_downtrend and close < higher_tf_ma) : true

// Enhanced momentum confirmation
float rate_of_change = ta.roc(close, momentum_lookback)
bool strong_momentum = in_uptrend ? rate_of_change > 0 : in_downtrend ? rate_of_change < 0 : true

// Calculate volume SMA globally to ensure consistent execution
var float volume_sma_20 = ta.sma(volume, 20)
volume_sma_20 := ta.sma(volume, 20)  // Update on each bar

// Volume filter
bool volume_filter_passed = not volume_filter or (volume > volume_sma_20 * min_volume_threshold)

// Candlestick pattern confirmation
bool bullish_candle_confirmation = f_detect_bullish_candle_pattern()
bool bearish_candle_confirmation = f_detect_bearish_candle_pattern()

// --- ENHANCED SIGNAL QUALITY CALCULATION with Wave Analysis ---
float signal_quality_score = 0.0

// Add Trend Speed confirmation factors
float trend_speed_factor = 0.0

// Calculate trend speed factor based on current ratio and signal quality
if math.abs(current_ratio) > min_wave_ratio
    // Strong trend speed signal
    trend_speed_factor := 1.0
else if math.abs(current_ratio) > min_wave_ratio * 0.7
    // Moderate trend speed signal
    trend_speed_factor := 0.7
else if math.abs(current_ratio) > min_wave_ratio * 0.5
    // Weak trend speed signal
    trend_speed_factor := 0.4
// else trend_speed_factor remains 0.0

// Add higher timeframe bias from the S/R analysis
float htf_bias_factor = 0.0
if include_sr
    if in_uptrend and (long_bias_1m or long_bias_5m)
        htf_bias_factor := long_bias_1m and long_bias_5m ? 1.0 : 0.5
    else if in_downtrend and (short_bias_1m or short_bias_5m)
        htf_bias_factor := short_bias_1m and short_bias_5m ? 1.0 : 0.5
    // else factor remains 0

// Multi-factor signal quality calculation based on market context
// Weight each component based on its importance in overall signal quality
if in_uptrend
    // For uptrends, we want low-medium volatility and positive momentum
    signal_quality_score := (
         (volatility_percentile > 0.2 and volatility_percentile < 0.7 ? 1.5 : 0.5) +  // 37.5%
         (normalized_velocity > 0 ? 1.0 : 0.0) +                                      // 25.0%
         (price_acceleration > 0 ? 0.5 : 0.0) +                                       // 12.5%
         (trend_speed_factor * 0.5) +                                                 // 12.5%
         (htf_bias_factor * 0.5)                                                      // 12.5%
         ) / 4.0  // Normalize to 0-1 range
else if in_downtrend
    // For downtrends, we want low-medium volatility and negative momentum
    signal_quality_score := (
         (volatility_percentile > 0.2 and volatility_percentile < 0.7 ? 1.5 : 0.5) +  // 37.5%
         (normalized_velocity < 0 ? 1.0 : 0.0) +                                      // 25.0%
         (price_acceleration < 0 ? 0.5 : 0.0) +                                       // 12.5%
         (trend_speed_factor * 0.5) +                                                 // 12.5%
         (htf_bias_factor * 0.5)                                                      // 12.5%
         ) / 4.0  // Normalize to 0-1 range
else
    // For ranging markets, we want very low volatility and momentum near zero
    signal_quality_score := (
         (volatility_percentile < 0.3 ? 1.5 : 0.5) +                                  // 37.5%
         (math.abs(normalized_velocity) < 0.5 ? 1.0 : 0.0) +                          // 25.0%
         (math.abs(price_acceleration) < 0.2 ? 0.5 : 0.0) +                           // 12.5%
         (trend_speed_factor * 0.5) +                                                 // 12.5%
         (htf_bias_factor * 0.5)                                                      // 12.5%
         ) / 4.0  // Normalize to 0-1 range

// Signal quality passes threshold check
bool high_quality_signal = signal_quality_score >= signal_quality_threshold

// Break down complex conditions into readable components for signal confirmation
bool confirmed_buy_string_1 = bottom and ao_bullish and (ao_cross_bull or AO > AO[1]) and price_near_support and bullish_candle_confirmation
bool confirmed_buy_string_2 = (require_trend_alignment ? in_uptrend : true) and volatility_within_range and volume_filter_passed and strong_trend_aligned and strong_momentum and high_quality_signal
bool confirmed_sell_string_1 = top and ao_bearish and (ao_cross_bear or AO < AO[1]) and price_near_resistance and bearish_candle_confirmation
bool confirmed_sell_string_2 = (require_trend_alignment ? in_downtrend : true) and volatility_within_range and volume_filter_passed and strong_trend_aligned and strong_momentum and high_quality_signal
bool alt_confirmed_buy_string_1 = simple_bottom and ao_bullish and (ao_cross_bull or AO > AO[1]) and price_near_support and bullish_candle_confirmation
bool alt_confirmed_buy_string_2 = (require_trend_alignment ? in_uptrend : true) and volatility_within_range and volume_filter_passed and strong_trend_aligned and strong_momentum and high_quality_signal
bool alt_confirmed_sell_string_1 = simple_top and ao_bearish and (ao_cross_bear or AO < AO[1]) and price_near_resistance and bearish_candle_confirmation
bool alt_confirmed_sell_string_2 = (require_trend_alignment ? in_downtrend : true) and volatility_within_range and volume_filter_passed and strong_trend_aligned and strong_momentum and high_quality_signal

// Stricter signal confirmations with AO crossover and trend alignment
bool confirmed_buy = confirmed_buy_string_1 and confirmed_buy_string_2
bool confirmed_sell = confirmed_sell_string_1 and confirmed_sell_string_2

// Alternative confirmation including simple signals
bool alt_confirmed_buy = alt_confirmed_buy_string_1 and alt_confirmed_buy_string_2
bool alt_confirmed_sell = alt_confirmed_sell_string_1 and alt_confirmed_sell_string_2

// Final trading signals that limit to one signal per swing
var int last_buy_bar = 0
var int last_sell_bar = 0

// Only allow one signal per cooldown period
bool valid_buy_signal = confirmed_buy or alt_confirmed_buy
bool valid_sell_signal = confirmed_sell or alt_confirmed_sell

// Additional trend speed filter for signals
bool trend_speed_buy_confirm = valid_buy_signal and (math.abs(current_ratio) >= min_wave_ratio * 0.7)
bool trend_speed_sell_confirm = valid_sell_signal and (math.abs(current_ratio) >= min_wave_ratio * 0.7)

// Final signals with cooldown and session filter
bool final_buy_signal_raw = trend_speed_buy_confirm and (bar_index - last_buy_bar > signal_cooldown)
bool final_sell_signal_raw = trend_speed_sell_confirm and (bar_index - last_sell_bar > signal_cooldown)

// Apply session filter
bool final_buy_signal = final_buy_signal_raw and in_session
bool final_sell_signal = final_sell_signal_raw and in_session

// Update last signal bars
if final_buy_signal
    last_buy_bar := bar_index
if final_sell_signal
    last_sell_bar := bar_index

// ====================================================================================
// ＳＩＭＰＬＩＦＩＥＤ ＳＬ ＬＯＧＩＣ
// ====================================================================================

// Calculate adaptive SL multipliers based on market phase and volatility
float sl_phase_multiplier = 1.0
if market_phase == "UPTREND"
    sl_phase_multiplier := 1.5
else if market_phase == "DOWNTREND"
    sl_phase_multiplier := 1.5
else if market_phase == "ACCUMULATION"
    sl_phase_multiplier := 1.2
else if market_phase == "DISTRIBUTION"
    sl_phase_multiplier := 1.2

// Apply regime modifiers to risk parameters
if use_regime_filter
    sl_phase_multiplier := sl_phase_multiplier * regime_sl_modifier

// Calculate stop levels for labels
float long_stop_level = low - volatility * vol_multiplier * sl_phase_multiplier
float short_stop_level = high + volatility * vol_multiplier * sl_phase_multiplier

// ====================================================================================
// ＰＬＯＴＳ ＦＯＲ ＡＬＥＲＴ ＣＯＮＤＩＴＩＯＮＳ - Define these early
// ====================================================================================

// Create plots specifically for alert conditions
// These must be defined outside any conditional blocks
plot(signal_quality_score * 100, "Signal Quality", color=color.new(color.blue, 100), display=display.none)

// Plot the weather status as a number (for alert conditions)
int weather_code = 0  // 0=NEUTRAL, 1=WARM, 2=HOT, 3=BURNING, -1=COLD, -2=FROZEN, -3=FREEZING
if color_level <= -1.0
    weather_code := -3  // FREEZING
else if color_level <= -0.66
    weather_code := -2  // FROZEN
else if color_level <= -0.33
    weather_code := -1  // COLD
else if color_level < 0.33
    weather_code := 0   // NEUTRAL
else if color_level < 0.66
    weather_code := 1   // WARM
else if color_level < 1.0
    weather_code := 2   // HOT
else
    weather_code := 3   // BURNING
plot(weather_code, "Weather Code", color=color.new(color.blue, 100), display=display.none)

// Plot the market regime for alerts
plot(market_regime == "TRENDING BULL" ? 1 :
     market_regime == "TRENDING BEAR" ? 2 :
     market_regime == "VOLATILE" ? 3 :
     market_regime == "RANGING" ? 4 : 0,
     "Market Regime Code", color=color.new(color.blue, 100), display=display.none)

// Also create a plot for entry/stop levels so alerts can reference them
plot(long_stop_level, "Long Stop Level", color=color.new(color.blue, 100), display=display.none)
plot(short_stop_level, "Short Stop Level", color=color.new(color.blue, 100), display=display.none)

// Plot the wave ratio for alerts
plot(math.abs(current_ratio) * 100, "Wave Ratio", color=color.new(color.blue, 100), display=display.none)

// ====================================================================================
// ＰＬＯＴＳ ＆ ＤＩＳＰＬＡＹ
// ====================================================================================

// Plot Support & Resistance Bands with weather coloring
ph = plot(highest_src, "Resistance Band", color=not clean_chart_mode ? red_color : na, linewidth=1)
plot(mid, "Middle Band", color=not clean_chart_mode ? heatmap_color : na, linewidth=1)
pl = plot(lowest_src, "Support Band", color=not clean_chart_mode ? green_color : na, linewidth=1)

// Calculate mid price for ATR bands
float mid_price = ta.sma(close, 20)

// Calculate ATR bands globally
float upper_band1 = mid_price + adaptive_atr * 1.0
float lower_band1 = mid_price - adaptive_atr * 1.0
float upper_band2 = mid_price + adaptive_atr * 2.0
float lower_band2 = mid_price - adaptive_atr * 2.0

// Plot ATR bands
plot(show_atr_bands ? upper_band1 : na, "ATR Band +1", color.new(color.blue, 70))
plot(show_atr_bands ? lower_band1 : na, "ATR Band -1", color.new(color.blue, 70))
plot(show_atr_bands ? upper_band2 : na, "ATR Band +2", color.new(color.blue, 80))
plot(show_atr_bands ? lower_band2 : na, "ATR Band -2", color.new(color.blue, 80))

// Export key values for potential reference by other indicators
plot(trendspeed, "Trend Speed", color=color.new(color.blue, 100), display=display.none)
plot(dominance_avg_value, "Dominance Value", color=color.new(color.blue, 100), display=display.none)
plot(signal_quality_score, "Signal Quality", color=color.new(color.blue, 100), display=display.none)
plot(wave_size_ratio_avg, "Wave Ratio Avg", color=color.new(color.blue, 100), display=display.none)

// Entry Zone Highlighting with weather colors
if show_entry_zones and barstate.islast
    var support_zone = box.new(bar_index[20], lowest_src + (price_range * 0.1), bar_index, lowest_src,
         bgcolor=color.new(color.from_gradient(0, -1, 1, color.aqua, color.yellow), 90),
         border_color=color.new(color.green, 70))
    box.set_right(support_zone, bar_index)
    box.set_top(support_zone, lowest_src + (price_range * 0.1))
    box.set_bottom(support_zone, lowest_src)

    var resistance_zone = box.new(bar_index[20], highest_src, bar_index, highest_src - (price_range * 0.1),
         bgcolor=color.new(color.from_gradient(0, -1, 1, color.yellow, color.red), 90),
         border_color=color.new(color.red, 70))
    box.set_right(resistance_zone, bar_index)
    box.set_top(resistance_zone, highest_src)
    box.set_bottom(resistance_zone, highest_src - (price_range * 0.1))

// Global plot statements for pattern signals
plotshape(
 series=simple_bottom and not clean_chart_mode,
 title="Simple Support Signal",
 style=shape.circle,
 location=location.belowbar,
 color=color.new(green_color, 40),
 size=size.small,
 force_overlay=true)

plotshape(
 series=simple_top and not clean_chart_mode,
 title="Simple Resistance Signal",
 style=shape.circle,
 location=location.abovebar,
 color=color.new(red_color, 40),
 size=size.small,
 force_overlay=true)

plotshape(
 series=bottom and not clean_chart_mode,
 title="Support Signal",
 style=shape.circle,
 location=location.belowbar,
 color=color.new(green_color, 60),
 size=size.small,
 force_overlay=true)

plotshape(
 series=top and not clean_chart_mode,
 title="Resistance Signal",
 style=shape.circle,
 location=location.abovebar,
 color=color.new(red_color, 60),
 size=size.small,
 force_overlay=true)

// Potential early signals (if enabled)
plotshape(
 series=potential_bottom and show_potential_signals and not clean_chart_mode,
 title="Potential Support",
 style=shape.diamond,
 location=location.belowbar,
 color=color.new(green_color, 70),
 size=size.tiny,
 force_overlay=true)

plotshape(
 series=potential_top and show_potential_signals and not clean_chart_mode,
 title="Potential Resistance",
 style=shape.diamond,
 location=location.abovebar,
 color=color.new(red_color, 70),
 size=size.tiny,
 force_overlay=true)

// Always show confirmed signals even in clean chart mode
plotshape(
 series=final_buy_signal,
 title="Confirmed Buy",
 style=shape.triangleup,
 location=location.belowbar,
 color=color.green,
 size=size.large,
 force_overlay=true)

plotshape(
 series=final_sell_signal,
 title="Confirmed Sell",
 style=shape.triangledown,
 location=location.abovebar,
 color=color.red,
 size=size.large,
 force_overlay=true)

// ---------- Add Entry Labels ----------
if show_entry_labels
    if final_buy_signal
        label.new(
         bar_index, low - atr_14, // Position label below bar
         "BUY\n" +
         "Entry: " + str.tostring(close, "#.####") +
         "\nSL: " + str.tostring(long_stop_level, "#.####") +
         "\nQuality: " + str.tostring(signal_quality_score * 100, "#.#") + "%" +
         "\nWave Ratio: " + str.tostring(math.abs(current_ratio), "#.##") + "x",
         color=color.new(color.green, 20), // Lighter background
         style=label.style_label_up,
         textcolor=color.black, // Black text for better contrast on light green
         size=size.normal)

    if final_sell_signal
        label.new(
         bar_index, high + atr_14, // Position label above bar
         "SELL\n" +
         "Entry: " + str.tostring(close, "#.####") +
         "\nSL: " + str.tostring(short_stop_level, "#.####") +
         "\nQuality: " + str.tostring(signal_quality_score * 100, "#.#") + "%" +
         "\nWave Ratio: " + str.tostring(math.abs(current_ratio), "#.##") + "x",
         color=color.new(color.red, 20), // Lighter background
         style=label.style_label_down,
         textcolor=color.black, // Black text for better contrast on light red
         size=size.normal)

// ====================================================================================
// ＡＬＥＲＴ ＣＯＮＤＩＴＩＯＮＳ (Fixed with const strings)
// ====================================================================================

// MAIN CONSOLIDATED ALERT (one alert to catch everything)
alertcondition(
     final_buy_signal,
     title="FKS Buy Signal",
     message="{{ticker}} 🟢 BUY SIGNAL: Quality {{plot('Signal Quality')}}%, Wave Ratio {{plot('Wave Ratio')}}%, Weather: {{plot('Weather Code')}}")

alertcondition(
     final_sell_signal,
     title="FKS Sell Signal",
     message="{{ticker}} 🔴 SELL SIGNAL: Quality {{plot('Signal Quality')}}%, Wave Ratio {{plot('Wave Ratio')}}%, Weather: {{plot('Weather Code')}}")

alertcondition(
     potential_bottom and show_potential_signals,
     title="FKS Potential Support",
     message="{{ticker}} 🟡 POTENTIAL SUPPORT: Possible buy setup forming")

alertcondition(
     potential_top and show_potential_signals,
     title="FKS Potential Resistance",
     message="{{ticker}} 🟡 POTENTIAL RESISTANCE: Possible sell setup forming")

alertcondition(
     regime_changed,
     title="FKS Market Regime Change",
     message="{{ticker}} 🔄 REGIME CHANGE: Market shifted to {{plot('Market Regime Code')}}")

alertcondition(
     session_started,
     title="FKS Session Started",
     message="{{ticker}} ⏰ SESSION STARTED: Trading session has begun")

alertcondition(
     session_ended,
     title="FKS Session Ended",
     message="{{ticker}} ⏰ SESSION ENDED: Trading session has closed")

// Special consolidated signal - separate conditions for each signal type
alertcondition(
     final_buy_signal or final_sell_signal or
     (potential_bottom and show_potential_signals) or
     (potential_top and show_potential_signals) or
     regime_changed or session_started or session_ended,
     title="FKS All Signals",
     message="{{ticker}} FKS Signal Detected (see indicator for details)")
